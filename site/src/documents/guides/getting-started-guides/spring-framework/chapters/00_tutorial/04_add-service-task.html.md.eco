---
title: 'Add a Spring Bean Service Task'
shortTitle: 'Spring Bean Service Task'
category: 'Tutorial'
---

Now that we know how to bootstrap the process engine in a Spring Application context, we can add a BPMN 2.0 process
model and interact with the process form inside our Spring beans. In this section we will

1. [Model an executable BPMN 2.0 process.](#servicetask/model)
2. [Use Spring auto-deployment for BPMN 2.0 processes.](#servicetask/deploy)
3. [Start a process instance from a Spring bean.](#servicetask/start)
4. [Invoke a Spring bean from a BPMN 2.0 Service task.](#servicetask/invoke)

<section id="servicetask/model">
  <h3>Model an executable BPMN 2.0 process</h3>
  <div class="row">
    <div class="col-xs-6 col-sm-6 col-md-3">
      <img data-img-thumb src="ref:asset:/assets/img/getting-started/spring-framework/process-model.png"/>
    </div>
    <div class="col-xs-9 col-sm-9 col-md-9">
      <p>
        We start by modeling an executable process using the camunda Modeler. The process should look as depicted in the screenshot to the left.
      </p>
      <div class="alert alert-info">
        If you are unfamiliar with modeling an executable process, you can read the <a href ="ref:/guides/getting-started-guides/developing-process-applications/#tutorial-model-a-process"><em>Model a Process</em></a> section of the <a href="ref:/guides/getting-started-guides/developing-process-applications/">Developing Process Applications</a> tutorial.
      </div>
      <p>
        When you are done, save the process model.
      </p>
    </div>
  </div>
</section>

<section id="servicetask/deploy">
  <h3>Use Spring auto-deployment for BPMN 2.0 processes</h3>
  <div class="row">
    <div class="col-md-12">
      <p>
        For the process to be deployed, we use the auto-deployment feature provided by the camunda engine Spring integration. In order to use this feature, modify the definition of the <code>processEngineConfiguration</code> bean inside your <code>src/main/webapp/WEB-INF/applicationContext.xml</code> file:
      </p>
      <div class="app-source" data-source-code="autodeployment" annotate="code-annotations" ></div>
    </div>
  </div>

  <div class="panel-group" id="accAutoDeployment">
    <div class="panel panel-default">
      <div class="panel-heading">
        <a class="accordion-toggle collapsed" data-toggle="collapse" data-parent="#accAutoDeployment" href="#accAutoDeploymentCollapsed"> <i class="icon-thumbs-up"></i>
          Alternative: Auto-deployment using <code>META-INF/processes.xml</code>
        </a>
      </div>
      <div id="accAutoDeploymentCollapsed" class="panel-collapse collapse">
        <div class="panel-body">
          <p>
            The <code>deploymentResources</code> provide basic auto-deployment features. If you need more control over the deployment process, you can use the processes.xml based deployment options in combination with <code>SpringProcessApplication</code>. This feature works with both the embedded process engine (as used in this tutorial) as well as the shared process engine. In order to use the <code>META-INF/processes.xml</code> based deployment, you must make the following changes in the application context file:
          </p>
          <div class="app-source" data-source-code="applicationContext-withSpringPa" annotate="code-annotations" ></div>
          <p>
            Now you can add a <code>META-INF/processes.xml</code> file:
          </p>
          <div class="app-source" data-source-code="processes.xml" annotate="code-annotations" ></div>
        </div>
      </div>
    </div>
  </div>
</section>

<section id="servicetask/start">
  <h3>Start a process instance from a Spring bean</h3>
  <div class="row">
    <div class="col-md-12">
      <p>
        The next step consists of starting a process instance from a Spring Bean. We will simply add a Spring Bean to the application context which injects to the process engine and starts a single process instance from an <code>afterPropertiesSet()</code> Method:
      </p>
      <div class="app-source" data-source-code="starter-java" annotate="code-annotations" ></div>
      <p>
        We add the Spring bean to the applicationContext.xml file:
      </p>
      <div class="app-source" data-source-code="starter-xml" annotate="code-annotations" ></div>
    </div>
  </div>
</section>

<section id="servicetask/invoke">
  <h3>Invoke a Spring bean from a BPMN 2.0 Service task</h3>
  <div class="row">
    <div class="col-xs-6 col-sm-6 col-md-3">
      <img data-img-thumb src="ref:asset:/assets/img/getting-started/spring-framework/service-task.png"/>
    </div>
    <div class="col-xs-9 col-sm-9 col-md-9">
      <p>
        Referencing a Spring Bean from a BPMN 2.0 Service Task is simple. As shown in the screenshot to the left, we have to select the service task in the camunda Modeler and provide an expression in the <em>Expression Delegate</em> Field. We type <code>${calculateInterestService}</code>.
      </p>
    </div>
  </div>
  <p>Finally, we add the Java class implementing the <code>JavaDelegate</code> interface.</p>
  <div class="app-source" data-source-code="service-java" annotate="code-annotations" ></div>
  <p>And register it as a Spring Bean in the application context.</p>
  <div class="app-source" data-source-code="service-xml" annotate="code-annotations" ></div>
  <p>
    If you redeploy the application, you should see the following message in the logfile, meaning that the service task was executed.
  </p>
  <pre class="console">
org.camunda.bpm.engine.impl.ProcessEngineImpl <init>
  INFORMATION: ProcessEngine engine created
Spring Bean invoked
org.springframework.web.context.ContextLoader initWebApplicationContext
  INFORMATION: Root WebApplicationContext: initialization completed in 1960 ms
  </pre>
</section>

<%- @partial('get-tag.html.eco', @, {repo: "camunda-get-started-spring", tag: "Step-3"}) %>
